---
layout: post
title: Rascando una picaz√≥n, o como mejoramos las cosas que usamos
subtitle: Una historia de open source, performance y un hoodie.
author: Felipe Sateler
tags: [github, swag, view_component, ruby]
date: 2022-05-10 10:00 -0300
images_path: "/assets/images/2022-05-10-rascando-picazon-como-mejoramos-cosas-usamos"
background: "/assets/images/2022-05-10-rascando-picazon-como-mejoramos-cosas-usamos/portada.jpg"
---
Como anuncio en el t√≠tulo de este post, esta historia trata de c√≥mo logr√© optimizar el rendimiento de un componente Open Source creado para Rails. Pero antes de comenzar, entremos un poco en contexto ¬øQu√© es [ViewComponent](https://github.com/github/view_component){:target="_blank" rel="noopener"}?

### La gema

ViewComponent es una librer√≠a desarrollada por Github para hacer componentes visuales en Ruby on Rails. En Buk hoy utilizamos [Cells](https://github.com/trailblazer/cells){:target="_blank" rel="noopener"} por razones que quiz√°s ameritan otro post. üòâ

Ambas librer√≠as tienen una filosof√≠a fundamental bastante distinta. Por un lado Cell y sus autores buscan separarse de Rails, teniendo incluso su propio [framework](https://trailblazer.to/2.0/index.html){:target="_blank" rel="noopener"}. Por otro lado ViewComponent tiene como eje central integrarse lo m√°s transparentemente posible con Rails. Es parte de la iniciativa de Github para llevar todo a "lo m√°s est√°ndar posible", lo que los ha llevado incluso a [desarrollar features en el propio framework](https://github.com/Rails/Rails/pull/36388) en vez de hacer workarounds o monkey patches en la gema. Adem√°s en este momento ViewComponent tiene una comunidad m√°s activa que Cells en la comunidad, un punto a tener en cuenta.

Sin importar mi opini√≥n personal de cual gema o incluso cu√°l framework sea mejor, la realidad es que Rails es el centro de gravedad en el universo de Ruby, as√≠ que con la intenci√≥n de ir hacia lo que nos ofrezca una mejor integraci√≥n con Rails tom√© la iniciativa de empezar a evaluar ViewComponent como un posible reemplazo para Cell.

### El problema

El primer inconveniente que encontr√© fue que la gema era bastante lenta. ¬øComo es posible que una gema usada en uno de los sitios de mayor tr√°fico sea tan lenta? Indagando en el repositorio, [descubro que no soy el primero en darse cuenta](https://github.com/github/view_component/issues/345). Un detalle interesante es que la lentitud solo se observa en desarrollo, no en producci√≥n. Esto explica por qu√© era posible de usar en un sitio del tr√°fico de Github, pero de todas maneras la experiencia de desarrollo era poco satisfactoria.

Siempre es bueno hacer un peque√±o programa que muestre un problema, y el que desarroll√© fue utilizando la gema [rack-mini-profiler](https://github.com/MiniProfiler/rack-mini-profiler) para poder medir el tiempo que demora:

```ruby
<% Rack::MiniProfiler.step('component') do %>
  <% 10_000.times do %>
    <%= render SpecialInput::CheckboxComponent.new(form: f, name: 'test', title: 'asdf') %>
    <br/>
  <% end %>
<% end %>
```

El resultado en mi computador fue que demor√≥ 7,6 segundos en renderizar los 10.000 componentes.

### Breve interludio: ¬øc√≥mo funcionan las librer√≠as visuales?

Un detalle que tendremos que entender antes de ir al fix es la manera en que funcionan las librer√≠as visuales (sean ActionView, Cells o ViewComponent). El concepto fundamental es que hay un template (por defecto `*.html.erb`, pero podr√≠a ser tambi√©n HAML o Slim) que renderizar√° un cierto HTML. Este template es tomado por el procesador correspondiente, y compilado[] a un m√©todo ruby.

Pero ¬øpor qu√© era tan lenta la gema? Antes de entrar a la respuesta de eso es importante aclarar que la mayor√≠a de las gemas que se utilizan para componentes visuales en Ruby funcionan de una manera muy similar; lo que hacen es tomar el template (*.erb) y ~~compilarlo~~ transpilarlo a un m√©todo Ruby, lo que finalmente genera el c√≥digo de la vista, es decir, un template como este:

```erb
<div>
  <%= algun_valor %>
</div>
```

Se transpila en un m√©todo que hace esencialmente lo siguiente:

```ruby
def autogenerated_method_XYZ1234
  output_buffer = ActiveSupport::SafeBuffer.new
  output_buffer.safe_append = '
<div>
'.freeze
  output_buffer.append = algun_valor
  output_buffer.safe_append = '
</div>
'.freeze
  output_buffer.to_s
end
```

Entonces cuando hacemos `render 'mi_vista'`, la librer√≠a internamente sabe que debe invocar el m√©todo `autogenerated_method_XYZ1234`, y obtenemos el HTML como resultado.

### De vuelta al problema

En desarrollo es deseable que cuando se edite un template el framework autom√°ticamente detecte que √©ste cambi√≥ y regenere el m√©todo Ruby. En producci√≥n este comportamiento no es necesario, el m√©todo puede vivir hasta que la aplicaci√≥n sea reiniciada. El problema que ten√≠a ViewComponent es que en desarrollo *siempre* estaba recompilando el m√©todo (aunque estuviesemos sirviendo el mismo request). Esto evidentemente es lento porque debemos _parsear_ el template, convertir en c√≥digo Ruby y luego pedirle al int√©rprete que lo parsee, *cada vez que queremos renderizar el componente*. Esto hac√≠a bastante inc√≥modo el desarrollo si tienes por ejemplo un componente que se renderiza en una tabla con muchos elementos.

Esto ocurr√≠a porque ViewComponent estaba [siempre indicando](https://github.com/github/view_component/blob/990b9bae7c189304b8465f30281cf48102547805/lib/view_component/base.rb#L197) que el template no estaba compilado cuando `cache_template_loading` es falso. Esto fuerza a que siempre se recompile.

### La soluci√≥n

En ingenier√≠a la primera pregunta ante un problema siempre debe ser: ¬øY c√≥mo lo hace el resto del mundo entonces? As√≠ que decid√≠ investigar como lo hace ActionView, la librer√≠a nativa de Rails. Descubr√≠ que ActionView construye un cach√© de m√©todos compilados, para evitar regenerar el m√©todo en cada request. La pregunta es entonces ¬øC√≥mo se invalida este cach√©? Ya vimos que ViewComponent _solucion√≥_ ese problema simplemente desactivando el cach√© en desarrollo. En ActionView, el responsable es la clase [ActionView::CacheExpiry](https://github.com/rails/rails/blob/3cd1b19ff2e49642191c598d620b87ffe5ec6cda/actionview/lib/action_view/cache_expiry.rb), el cual es enganchado en el [Executor](https://guides.rubyonrails.org/threading_and_code_execution.html) de Rails [cuando la configuraci√≥n es la correcta](https://github.com/rails/rails/blob/3cd1b19ff2e49642191c598d620b87ffe5ec6cda/actionview/lib/action_view/railtie.rb#L96-L99).

Con esta informaci√≥n volv√≠ al issue de Github y coment√© el resultado de mi investigaci√≥n. Ah√≠ Joel Hawksley (mantenedor de la gema) pregunta si pod√≠a implementar la soluci√≥n en un PR.

La invalidaci√≥n de cach√© en Rails es sofisticada, pues la clase `CacheExpiry` s√≥lo invalida el cach√© si se ha modificado alg√∫n template. Porque lo perfecto es enemigo de lo bueno üòâ decid√≠ que bastaba con que se invalidara en cada request. Implement√© mi soluci√≥n creando una clase que abstraiga el cach√© de m√©todos y luego enganchando una invalidaci√≥n de este cach√© en el `Executor` de Rails. El resultado se puede ver en el [PR 372](https://github.com/github/view_component/pull/372). Con este cambio logr√© reducir el tiempo del programa de ejemplo a 0.6s, es decir, el tiempo de ejecuci√≥n se redujo a un 7.9% del original.

Tras un par de iteraciones de review, el PR fue integrado a la rama principal y lanzado en la [version 2.9.0](https://github.com/github/view_component/releases/tag/v2.9.0) de la gema. A los pocos d√≠as me contacta Joel pregunt√°ndome mi direcci√≥n para enviarme un hoodie de Github. Y as√≠ es como tengo un poler√≥n de Github. üòú

![Github hoodie]({{page.images_path}}/hoodie.jpg)

### Pensamientos adicionales

Esta experiencia me deja con algunos pensamientos:

- El tener acceso a un ecosistema Open Source maduro (como es el caso del ecosistema Rails) presenta excelentes oportunidades de aprendizaje. En un par de clicks tuve acceso al c√≥digo completo de Rails, pude ver como funcionaba su cach√© y c√≥mo funcionaba la invalidaci√≥n de este.
- Que tu plataforma sea Open Source (o completamente interna) te presenta oportunidades de mejorarla. Hay una tendencia natural a asumir que la plataforma es ex√≥gena, alterada por otras personas y otras prioridades. Esto se conoce como _platform problem_. Tener acceso a modificar la plataforma es bastante liberante, en que ya no tienes que hacer workarounds o hacks en tu c√≥digo. Eso s√≠, requiere que salgas un poco de lo que sea que est√°s logrando en este momento, para tomarte el tiempo de reparar las fundaciones.
- ¬°Es posible aprender en proyectos reales! Solo debes buscar un problema en un proyecto activo. Aunque no tenga un final tan feliz como el de este post (como me sucedi√≥ con [otro PR](https://github.com/github/view_component/pull/451)), siempre habr√° aprendizaje.
